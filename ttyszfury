#!/usr/bin/env python3
# encoding=UTF-8

# Copyright Â© 2022 Jakub Wilk <jwilk@jwilk.net>
# SPDX-License-Identifier: MIT

import argparse
import asyncio
import fcntl
import os
import random
import signal
import struct
import sys
import termios

async def _(x):
    f'{await "# Python >= 3.7 is required #"}'

prog = argparse.ArgumentParser().prog

def ushort(s):
    n = int(s)
    try:
        struct.pack('H', n)
    except struct.error:
        raise ValueError
    return n
ushort.__name__ = 'unsigned short int'

def main():
    ap = argparse.ArgumentParser()
    ap.add_argument('cmd', metavar='COMMAND', help='command to execute')
    ap.add_argument('args', metavar='ARGS', nargs=argparse.REMAINDER, help=argparse.SUPPRESS)
    for dim, dimension in dict(wd='width', ht='height').items():
        for lim in ['min', 'max']:
            default = 1 if lim == 'min' else f'original {dimension}'
            ap.add_argument(
                f'--{lim}-{dimension}',
                dest=f'{lim}_{dim}',
                metavar='N', type=ushort,
                help=f'{lim}imum tty {dimension} (default: {default})'
            )
    ap.add_argument('--interval',
        metavar='N', type=float,
        help='delay between resizes, in seconds (default: no delay)'
    )
    opts = ap.parse_args()
    opts.fd = sys.stdin.fileno()
    try:
        opts.sz = sz = os.get_terminal_size(opts.fd)
    except OSError as exc:
        print(f'{prog}: cannot get terminal size: {exc.strerror}', file=sys.stderr)
        sys.exit(-1)
    min_wd = opts.min_wd = opts.min_wd or 1
    min_ht = opts.min_ht = opts.min_ht or 1
    max_wd = opts.max_wd = opts.max_wd or sz.columns
    max_ht = opts.max_ht = opts.max_ht or sz.lines
    if min_ht > max_ht:
        ap.error(f'min height ({min_ht}) > max height ({max_ht})')
    if min_wd > max_wd:
        ap.error(f'min width ({min_wd}) > max width ({max_wd})')
    asyncio.run(amain(opts))

async def amain(opts):
    opts.queue = asyncio.Queue()
    await asyncio.gather(
        fury(opts),
        run_cmd(opts)
    )

def set_terminal_size(fd, wd, ht):
    winsize = struct.pack('H' * 4, ht, wd, 0, 0)
    fcntl.ioctl(fd, termios.TIOCSWINSZ, winsize)

async def fury(opts):
    fd = opts.fd
    attrs = termios.tcgetattr(fd)
    (orig_wd, orig_ht) = opts.sz
    errmsg = None
    try:
        while True:
            wd = random.randint(opts.min_wd, opts.max_wd)
            ht = random.randint(opts.min_ht, opts.max_ht)
            try:
                set_terminal_size(fd, wd, ht)
            except OSError as exc:
                print(f'{prog}: TIOCSWINSZ with ws_row={ht}, ws_col={wd} failed: {exc.strerror}', file=sys.stderr)
                sys.exit(-1)
            rc = None
            if opts.interval:
                try:
                    rc = await asyncio.wait_for(opts.queue.get(), timeout=opts.interval)
                except asyncio.TimeoutError:
                    pass
            else:
                await asyncio.sleep(0)
            if rc is None and not opts.queue.empty():
                rc = await opts.queue.get()
            if rc is not None:
                if rc >= 0:
                    sys.exit(rc)
                else:
                    sig = signal.Signals(-rc).name
                    errmsg = f'{prog}: child process terminated by {sig}'
                    sys.exit(-1)
    finally:
        termios.tcsetattr(fd, termios.TCSAFLUSH, attrs)
        set_terminal_size(fd, orig_wd, orig_ht)
        if errmsg is not None:
            print(errmsg, file=sys.stderr)
            errmsg = None

async def run_cmd(opts):
    proc = await asyncio.create_subprocess_exec(opts.cmd, *opts.args)
    rc = await proc.wait()
    await opts.queue.put(rc)

if __name__ == '__main__':
    main()

# vim:ts=4 sts=4 sw=4 et
